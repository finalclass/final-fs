{"name":"Final-FS","tagline":"Promised wrapper for node fs module with usefull additional set of functions.","body":"\r\n**MIT License** (see LICENSE.txt)\r\n\r\nFinal-FS is an utility library for file system operations.\r\nIt wrapps nodejs \"fs\" module and provides it's functions in promise pattern.\r\nAlso it has few additional useful set of functions.\r\nEvery aynchrouns function in final-fs module uses [when](https://github.com/cujojs/when) Promises.\r\n\r\nFor example, checking file existance can be done with this code:\r\n\r\n```js\r\nvar ffs = requtheire('final-fs');\r\n\r\nffs.exists('somefile.txt').then(function (exists) {\r\n    if (exists) {\r\n        console.log('The file really exists');\r\n    } else {\r\n        console.log('File somefile.txt does not exists');\r\n    }\r\n});\r\n```\r\n\r\n## Installation\r\n\r\n    npm install final-fs\r\n\r\n## Paths\r\n\r\nAll paths can be specified using array notation. If an array is given as an argument the path.resolved is called.\r\n\r\nFor example: `ffs.exists(path.resolve(__dirname, 'var', 'test'))` is same as `ffs.exists([__dirname, 'var', 'test'])`.\r\n\r\n## Chaining\r\n\r\nFinal-FS uses [when](https://github.com/cujojs/when) library for async calls so there is no worry about the callback hell.\r\n\r\nFor example reading a file as a json, altering json object and saving it again would look like this:\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    filePath = path.resolve(__dirname, 'data.json');\r\n\r\nffs.exists(filePath)\r\n    .then(function (exists) {\r\n        if (exists) {\r\n            return ffs.readJSON(filePath);\r\n        }\r\n        return {};\r\n    })\r\n    .then(function (obj) {\r\n        obj.hello = 'World!';\r\n        return ffs.writeJSON(filePath, obj);\r\n    })\r\n    .then(function () {\r\n        // file data.json is saved now\r\n    })\r\n    .otherwise(function (err) {\r\n        // If something on this call chain went wrong then this function will catch it\r\n    });\r\n```\r\n\r\nYou can even return the result and chain further in another function. Look at the source code of rmdirRecursive function\r\nto see how easy it is to work aysnchronous with files using Final-FS and [when](https://github.com/cujojs/when) library.\r\n\r\n## Additional functions provided with final-fs\r\n\r\n### rmdirRecursiveSync(dirPath:string) : void\r\n\r\nRecusrise remove all directory contents. Synchronous version\r\n\r\n###### Example: Remove ./tmp folder with it's contents.\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path');\r\n\r\nffs.rmdirRecursiveSync(path.resolve(__dirname, 'tmp'));\r\n// directory ./tmp is removed now\r\n```\r\n\r\n### rmdirRecursive(dirPath:string) : Promise\r\n\r\nRecursively remove directory. Asynchronous version\r\n\r\n###### Example: Remove ./tmp folder with it's contents\r\n\r\n```js\r\nvar ffs = require('final-fs')\r\n    path = require('path');\r\n\r\nffs.rmdirRecursive(path.resolve(__dirname, 'tmp'))\r\n    .then(function () {\r\n        // directory ./tmp is removed now\r\n    })\r\n    .otherwise(function (err) {\r\n        // something went wrong\r\n    });;\r\n```\r\n\r\n### writeJSON(filePath:string, obj:Object) : Promise\r\n\r\nConvert obj into json string and write it to the file in the filePath\r\n\r\n###### Example: Insert object into ./data.json file\r\n\r\n```js\r\nvar ffs = require('final-fs')\r\n    path = require('path'),\r\n    obj = {foo: 'bar'}\r\n    filePath = path.resolve(__dirname, 'data.json');\r\n\r\nffs.writeJSON(filePath, obj)\r\n    .then(function () {\r\n        // file data.json is written now\r\n    })\r\n    .otherwise(function(err) {\r\n        // something went wrong. See err for details\r\n    });\r\n```\r\n\r\n### readJSON(filePath:string) : Promise\r\n\r\nRead file content and turn it into js object\r\n\r\n###### Example: read file ./data.json and convert it into a js object.\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    filePath = path.resolve(__dirname, 'data.json');\r\n\r\nffs.readJSON(filePath)\r\n    .then(function (obj) {\r\n        // obj is now an object build from data.json file content\r\n    })\r\n    .otherwise(function (err) {\r\n        // something went wrong. See err for details\r\n    });\r\n```\r\n\r\n### dirInfo(dirPath:string) : Promise\r\n\r\nReturns an array of fs.Stat objects with additional filePath and fileName properties\r\n\r\n###### Example\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    dirPath = path.resolve(__dirname, 'var');\r\n\r\nffs.dirInfo(dirPath)\r\n    .then(function (stats) {\r\n        // stats is an array of fs.Stats objects with fileName and filePath properties\r\n    })\r\n    .otherwise(function (err) {\r\n        // error\r\n    });\r\n```\r\n\r\n### dirFiles(dirPath:string) : Promise\r\n\r\nReturns all the files from the directory.\r\n\r\n###### Example\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    dirPath = path.resolve(__dirname, 'var');\r\n\r\nffs.dirFiles(dirPath)\r\n    .then(function (filesOnly) {\r\n        // filesOnly is an array of directory files names\r\n    })\r\n    .otherwise(function (err) {\r\n        // error\r\n    });\r\n```\r\n\r\n### fileNameFilter(text:string) : string\r\n\r\nReturns provided `text` as a file name valid string.\r\n\r\n###### Example\r\n\r\n```js\r\nvar ffs = require('final-fs');\r\n\r\nvar fileName = ffs.fileNameFilter('an Inv@lid t$xt');\r\n// fileName is now: \"an-invlid-txt\"\r\n```\r\n\r\n## Node-fs module port\r\n\r\nFinal-FS uses [nodefs](https://github.com/bpedro/node-fs) module.\r\nThis module provides 2 functions:\r\n\r\n- mkdir\r\n- mkdirSync\r\n\r\nFinal-FS uses these 2 functions and wrappes mkdir asynchrouns function with a promise. It also changes their names:\r\n\r\n- mkdir becomes `mkdirRecursive`\r\n- mkdirSync becomes `mkdirRecursiveSync`\r\n\r\n### mkdirRecursiveSync(path:string, ?mode:number=0777) : void\r\n\r\nSynchronously creates a directory recursively.\r\n\r\n###### Exmaple. Create directory ./var/tmp/tmp2, when directory ./var does not exists\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    dirPath = path.resolve(__dirname, 'var', 'tmp', 'tmp2');\r\n\r\nffs.mkdirRecursiveSync(dirPath);\r\n// now ./var/tmp/tmp2 directory is created\r\n```\r\n\r\n### mkdirRecursive(path:string, ?mode:number=0777) : Promise\r\n\r\nAsynchronously creates a directory recursively.\r\n\r\n###### Exmaple. Create directory ./var/tmp/tmp2, when directory ./var does not exists\r\n\r\n```js\r\nvar ffs = require('final-fs'),\r\n    path = require('path'),\r\n    dirPath = path.resolve(__dirname, 'var', 'tmp', 'tmp2');\r\n\r\nffs.mkdirRecursiveSync(dirPath)\r\n    .then(function () {\r\n        // now ./var/tmp/tmp2 directory is created\r\n    })\r\n    .otherwise(function (err) {\r\n        // something went wrong\r\n    });\r\n```\r\n\r\n## Nodejs fs module functions\r\n\r\nThese functions work exatcly the same as in nodejs fs module However asynchrouns functions doesn't take any callbacks.\r\n  Instead a Promise is returned.\r\n\r\nThe rule is simple:\r\n\r\n- If callback tooked 2 arguments then error argument would be available in `otherwise` function and\r\nthe secound argument will be available in `then` function.\r\n- If only one argument is provided and it's an error then `otherwise` function would have this argument as it's own.\r\n- If only one argument is provided for the callback and it's not an error (for example the result of fs.exists function)\r\nthen this argument would be an argument for `then` function.\r\n\r\nPorted functions are:\r\n\r\n    rename(string, string) : Promise\r\n    renameSync(string, string) : void\r\n    ftruncate(number, number) : Promise\r\n    ftruncateSync(number, number) : void\r\n    truncate(string, number) : Promise\r\n    truncateSync(string, number) : void\r\n    chown(string, number, number) : Promise\r\n    chownSync(string, number, number) : void\r\n    fchown(number, number, number) : Promise\r\n    fchownSync(number, number, number) : void\r\n    lchown(string, number, number) : Promise\r\n    lchownSync(string, number, number) : void\r\n    chmod(string, number) : Promise\r\n    chmodSync(string, number) : Promise\r\n    fchmod(number, number) : Promise\r\n    fchmodSync(number, number) : void\r\n    lchmod(string, number) : Promise\r\n    lchmodSync(string, number) : void\r\n    stat(string) : Promise\r\n    lstat(string) : Promise\r\n    fstat(string) : Promise\r\n    statSync(string) : fs.Stats\r\n    lstatSync(string) : fs.Stats\r\n    fstatSync(string) : fs.Stats\r\n    link(string, string) : Promise\r\n    linkSync(string, string) : void\r\n    symlink(string, string, ?'dir'|'file'|'junction'='file') : Promise\r\n    symlinkSync(string, string, ?'dir'|'file'|'junction'='file') : void\r\n    readlink(string) : Promise\r\n    readlinkSync(string) : string\r\n    realpath(string, ?object=) : Promise\r\n    realpathSync(string, ?object=) : string\r\n    unlink(string) : Promise\r\n    unlinkSync(string) : void\r\n    rmdir(string) : Promise\r\n    rmdirSync(string) : void\r\n    mkdir(string, ?number=0777) : Promise\r\n    mkdirSync(string, ?number=0777) : void\r\n    readdir(string) : Promise\r\n    readdirSync(string) : string[]\r\n    close(number) : Promise\r\n    closeSync(number) : void\r\n    open(string, string, ?number=0666) : Promise\r\n    openSync(string, string, ?number=0666) : void\r\n    utimes(string, number, number) : Promise\r\n    utimesSync(string, number, number) : void\r\n    futimes(number, number, number) : Promise\r\n    futimesSync(number, number, number) : void\r\n    fsync(number) : Promise\r\n    fsyncSync(number) : void\r\n    write(number, Buffer, number, number, nbumber) : Promise\r\n    writeSync(number, Buffer, number, number, nbumber) : number\r\n    read(number, Buffer, number, number, number) : Promise\r\n    readSync(number, Buffer, number, number, number) : number\r\n    readFile(string, ?{?encoding:string=null, ?flag:string=r}=) : Promise\r\n    readFileSync(string, ?{?encoding:string, ?flag:string}=) : Buffer|string\r\n    writeFile(string, string|Buffer, ?{?encoding:string, ?mode:number, ?flag:string}=) : Promise\r\n    writeFileSync(string, string|Buffer, ?{?encoding:string, ?mode:number, ?flag:string}=) : void\r\n    appendFile(string, string|Buffer, ?{?encoding:string, ?mode:number, ?flag:string}=) : Promise\r\n    appendFileSync(string, string|Buffer, ?{?encoding:string, ?mode:number, ?flag:string}=) : void\r\n    watchFile(string, ?{persistent:boolean, interval:number}=, ?function(fs.Stats, fs.Stats)=) : void\r\n    unwatchFile(string, function(fs.Stats, fs.Stats)) : void\r\n    watch(string, ?{persistent:boolean, interval:number}=, ?function (string, string)) : fs.FSWatcher\r\n    exists(string) : Promise\r\n    existsSync(string) : boolean\r\n    createReadStream(string, ?{flags:'r', encoding: null, fd: null, mode: 0666, bufferSize: 66020, autoClose: true}) : ReadStream\r\n    createWriteStream(string, ?{flags: 'w', encoding: null, mode: 0666}=) : WriteStream\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}